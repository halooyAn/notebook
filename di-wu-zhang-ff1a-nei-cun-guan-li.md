# 对象池 {#对象池}

## 小整数对象池： {#小整数对象池：}

在一个程序中，\[-5,256\]之间的数字是经常被使用的。因此`Python`在程序运行过程中，定义好了一个小整数池，也就是说从-5到256之间的数字都是提前在内存中建立好的，不会被系统回收，并且以后你创建了一个变量是在这个范围之内，那么都是同一个对象。同样对于单个字母也是一样的。

示例：

```py
    a = 1
    b = 1
    # 以下两个值是一样的
    print(id(a))
    print(id(b))
    a = -6
    b = -6
    # 以下两个值是不一样的
    print(id(a))
    print(id(b))
    # 以下两个值是不一样的
    a = 257
    b = 257
    # 以下两个值是不一样的
    print(id(a))
    print(id(b))
```

## 对于只含英文字符的字符串，共用同一个对象： {#对于只含英文字符的字符串，共用同一个对象：}

如果两个字符串的字符都是一样，并且只包含英文字符。那么会共用同一个对象。示例代码如下：

```py
    a = "helloworld"
    b = "helloworld"
    # 以下两个值会相等
    print(id(a))
    print(id(b))

    a = "hello world"
    b = "hello world"
    # 以下两个值不想等
    print(id(a))
    print(id(b))
```
____
# Python垃圾回收机制 {#python垃圾回收机制}

## 引用计数： {#引用计数：}

在`Python`中，使用了引用计数这一技术实现内存管理。一个对象被创建完成后就有一个变量指向他，那么就说明他的引用计数为1，以后如果有其他变量指向他，引用计数也会相应增加，如果将一个变量不再执行这个对象，那么这个对象的引用计数减1。如果一个对象没有任何变量指向他，也即引用计数为0，那么这个对象会被`Python`回收。示例代码如下：

```py
    class Person(object):
        def __init__(self,name):
            self.name = name

        def __del__(self):
            print('%s执行了del函数'%self.name)

    while True:
        p1 = Person('p1')
        p2 = Person('p2')
        del p1
        del p2
        a = input('test:')
```

## 循环引用： {#循环引用：}

引用计数这一技术虽然可以在一定程度上解决内存管理的问题。但是还是有不能解决的问题，即**循环引用**。比如现在有两个对象分别为a和b，a指向了b，b又指向了a，那么他们两的引用计数永远都不会为0。也即永远得不到回收。看以下示例：

```py
    class Person(object):
        def __init__(self,name):
            self.name = name

        def __del__(self):
            print('%s执行了del函数'%self.name)

    while True:
        p1 = Person('p1')
        p2 = Person('p2')
        # 循环引用后，永远得不到释放
        p1.next = p2
        p2.prev = p1
        del p1
        del p2
        a = input('test:')
```

## 标记清除和分代回收：

在Python程序中，每次你新创建了一个对象，那么就会将这个对象挂到一个叫做零代链表中（当然这个链表是`Python`内部的，`Python`开发者是没法访问到的）。比如现在你在程序中创建四个`Person`对象，分别叫做`p1`、`p2`、`p3`以及`p4`，然后`p1`与`p2`之间互相引用，并且让`p3`和`p4`的引用计数为2，示例代码如下：

```py
    import sys

    class Person(object):
        def __init__(self,name):
            self.name = name
            self.next = None
            self.prev = None

    p1 = Person('p1')
    p2 = Person('p2')
    p3 = Person('p3')
    p4 = Person('p4')

    p1.next = p2
    p2.prev = p1

    temp1 = p3
    temp2 = p4

    print(sys.getrefcount(p1))
    print(sys.getrefcount(p2))
    print(sys.getrefcount(p3))
    print(sys.getrefcount(p4))
```

以上代码实际上就会将`p1`和`p2`以及`p3`和`p4`挂在一个叫做零代链表中，示例图如下：  
![](/assets/零代链表.png)

我们可以看到，这时候`p1`引用了`p2`，而`p2`又引用了`p1`，因此这两个对象产生了循环引用。在后期即使我删除了`del p1`以及`del p2`，那么这两个对象也会得不到释放。  
![](/assets/del后的零代链表.png)

因此这时候`Python`就启用了一个新的垃圾回收的机制。如果创建的对象总和减去被释放的对象，达到一定的值（某个阈值），那么`Python`就会遍历这个零代链表，找到那些有相互引用的对象，将这些对象的引用计数减1，如果引用计数值为0了，那么就说明这个对象是可以被释放的，比如以上`p1`和`p2`，这时候就会释放`p1`和`p2`。接下来再将没有被释放的对象，挪动到一个新的链表中，这个链表叫做一代链表。  
![](/assets/1代链表.png)

在零代链表清理的次数达到某个阈值后，`Python`会去遍历一代链表，将那些没有得到释放的对象移动到二代链表。同样的原理，如果一代链表清理的次数达到某个阈值后，`Python`会去遍历二代链表，把垃圾对象进行回收。

## 弱代假说：

来看分代垃圾回收算法的核心行为：垃圾回收器会更频繁的处理新对象。一个新的对象即是你的程序刚刚创建的，而一个来的对象则是经过了几个时间周期之后仍然存在的对象。`Python`会在当一个对象从零代移动到一代，或是从一代移动到二代的过程中提升\(promote\)这个对象。

为什么要这么做？这种算法的根源来自于弱代假说\(weak generational hypothesis\)。这个假说由两个观点构成：首先是年青的对象通常死得也快，而老对象则很有可能存活更长的时间。

假定现在我用Python创建一个新对象：  
![](/assets/弱代假说.jpg)

根据假说，我的代码很可能仅仅会使用ABC很短的时间。这个对象也许仅仅只是一个方法中的中间结果，并且随着方法的返回这个对象就将变成垃圾了。大部分的新对象都是如此般地很快变成垃圾。然而，偶尔程序会创建一些很重要的，存活时间比较长的对象-例如web应用中的session变量或是配置项。

通过频繁的处理零代链表中的新对象，Python的垃圾收集器将把时间花在更有意义的地方：它处理那些很快就可能变成垃圾的新对象。同时只在很少的时候，当满足阈值的条件，收集器才回去处理那些老变量。

## 参考文档：

[http://www.jianshu.com/p/1e375fb40506](http://www.jianshu.com/p/1e375fb40506)

---

# gc模块 {#gc模块}

`Python`中的`gc`模块封装了许多和对象以及垃圾回收相关的方法。这节我们就来学习下这个模块。

## 导致引用计数+1的情况： {#导致引用计数1的情况：}

* 对象被创建，并被一个对象所引用。例如`a=23。`

* 对象被另外一个变量引用。例如`b=a`。

* 对象被作为参数传递给函数。例如`func(a)`。

* 对象被添加到容器中，比如添加到列表、元组、字典、集合中等。例如`temp=[a]`。

## 导致引用计数-1的情况：

* 引用这个对象的变量被删掉掉了。例如`del a`。

* 引用这个对象的变量指向其他的对象了。例如`a='abc'`。

* 函数作用域执行完毕后。比如一个函数中的临时变量，在这个函数执行结束后就会消失。

* 对象所在的这个容器被销毁，或者从这个容器中删除了这个对象，也会导致这个对象引用计数会减1。

## 查看一个对象的引用计数：
```py
    import sys
    a = "hello world"
    print(sys.getrefcount(a))
```
打印出来的引用计数，总是会比真实的引用计数多1，原因是因为你将这个对象传给了`getrefcount`函数，这个过程会给这个对象的引用计数加1.

## gc模块常用函数：

1. gc.set_debug(flags): 设置gc的debug日志，一般设置为`gc.DEBUG_LEAK`可以看到内存泄漏的对象。

2. gc.collect(generation)：执行垃圾回收。会将那些有循环引用的对象给回收了。这个函数可以传递参数，`0`代表只回收**第0代**的的垃圾对象、`1`代表回收**第0代和第1代**的对象，`2`代表回收**第0、1、2代**的对象。如果不传参数，那么会使用`2`作为默认参数。

3. gc.get_threshold()：获取`gc`模块执行垃圾回收的阈值。返回的是个元组，第0个是零代的阈值，第1个是1代的阈值，第2个是2代的阈值。

4. gc.set_threshold()：设置执行垃圾回收的阈值。

5. gc.get_count()：获取当前自动执行垃圾回收的计数器。返回一个元组。第0个是**零代**的垃圾对象的数量，第1个是零代链表遍历的次数，第2个是1代链表遍历的次数。

## 关于阈值和垃圾回收：
假设通过`gc.get_threshold()`返回的是`(700,10,10)`，那么意味着只要零代垃圾值到了700，就会执行`gc.collect(0)`，回收零代的垃圾值；只要**1代**垃圾值到了10，就会执行`c.collect(1)`，回收**零代和1代**的垃圾值。只要**2代**垃圾值到了10，就会执行`gc.collect(2)`，回收**零代和1代以及2代**的垃圾值。

## 注意点：
gc模块不能处理的是，如果两个循环引用的对象都实现了`__del__`方法，那么将不会进行垃圾回收，因此尽量不要在类中实现自己的`__del__`方法。否则发生循环引用后就会产生内存泄露。

## 参考文档：
http://luckylau.tech/2017/03/31/你懂python吗-13/



